using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;

/// <summary>
/// Alterado em 2020/10/27
///   -- string.Concat changed to string.Format
///   -- Array.Find changed to Array.Exist
///   -- Regex field changed to readonly
/// </summary>
public static class ObjectNamesManager
{
    //use to create regular expresions.
    //http://rubular.com/r/ImZaRigMv5              
    //ivate static Regex Pattern = new Regex(@"\.*?\([^\d]*(\d+)[^\d]*\)$");
    private static readonly Regex Pattern = new Regex(@"\((\d+)\)$");

    /// <summary>
    /// Make a unique name using the provided name as a base.
    /// If the target name is in the provided list of existing names, a unique name is generated by appending the next available numerical increment.
    /// </summary>
    /// <param name="ExistingNames">A list of pre-existing names.</param>
    /// <param name="name">Desired name to be used as is, or as a base.</param>
    /// <returns></returns>
    public static string GetUniqueName(string[] existingNames, string name, string space=" ")
    {
        if (Array.Exists(existingNames, (e => e == name)))
        {
            //return GetUniqueName(existingNames, Pattern.Replace(name, string.Concat("(", ++index, ")")));
            if (int.TryParse(Pattern.Match(name).Groups[1].Value, out int index))
                return GetUniqueName(existingNames, Pattern.Replace(name, string.Format("({0})", ++index)));
            else
                return GetUniqueName(existingNames, string.Concat(name, space, "(0)"));
        }

        return name;
    }

    /// <summary>
    /// Make a unique name using the provided name as a base.
    /// If the target name is in the provided dictionary of existing names, a unique name is generated by appending the next available numerical increment.
    /// </summary>
    /// <param name="ExistingNames">A dictionary of pre-existing names.</param>
    /// <param name="name">Desired name to be used as is, or as a base.</param>
    /// <returns></returns>
    public static string GetUniqueNameFromDictionary(Dictionary<string, System.Object> existingNames, string name, string space = " ")
    {   
        if (existingNames.ContainsKey(name))
        {
            if (int.TryParse(Pattern.Match(name).Groups[1].Value, out int index))
                return GetUniqueNameFromDictionary(existingNames, Pattern.Replace(name, string.Format("({0})", ++index)));
            else
                return GetUniqueNameFromDictionary(existingNames, string.Concat(name, space, "(0)"));
        }

        return name;
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="s"></param>
    /// <param name="notAllowedChars"></param>
    /// <returns></returns>
    public static bool ValidateName(string s, params char[] notAllowedChars)
    {
        int len = s.Length;
        int count = 0;

        for (int i = 0; i < len; ++i)
        {
            foreach (char c in notAllowedChars)
            {
                if (s[i] == c)
                    return false;
                else if (s[i] == ' ' || s[i] == '\0')// check spaces and voids
                    count++;
            }
        }

        return count != len;// if count == len there is only spaces on string
    }

    public static string RemoveCharacters(string s, params char[] notAllowedChars)
    {
        if (notAllowedChars != null)
        {
            string n = string.Empty;
            bool contains;

            for (int i = 0; i < s.Length; ++i)
            {
                contains = false;
                foreach (char c in notAllowedChars)
                {
                    if (s[i] == c)
                        contains = true;
                }
                if(!contains)
                    n += s[i];
            }

            return n;
        }

        return s;
    }

    public static bool ValidateIfNameHasntForbiddenCharacters(string s)
    {
        return ValidateName(s, '[', ']', '.');
    }

    public static string RemoveForbiddenCharacters(string s)
    {
        return RemoveCharacters(s, '[', ']', '.');
    }
}
